" vim: set foldmarker={,} foldlevel=0 foldmethod=marker spell:
" Author: Kyle Huang (https://github.com/kal444)
"
" Based on many others' vimrc files
"   many years ago, the initial version is http://www.guckes.net/vim/
"   then, it went through many modifications
"   recently, I'm inspired to look at more vim plugins and started to go
"   through this: https://github.com/square/maximum-awesome
"   some more 'sensible' settings from https://github.com/tpope/vim-sensible
"   recent additions from https://github.com/spf13/spf13-vim/blob/3.0/.vimrc
"    * really like the folding idea

" Identify platform {
silent function! OSX()
  return has('macunix')
endfunction
silent function! LINUX()
  return has('unix') && !has('macunix') && !has('win32unix')
endfunction
silent function! WINDOWS()
  return  (has('win32') || has('win64'))
endfunction
" }

" Set VIMRC location and runtime path {
" vimrc location can vary based on OSes
" see :version
" http://vim.wikia.com/wiki/Open_vimrc_file#Location_of_vimrc
"========== save vimrc location for later use
if WINDOWS()
  let vimrc='$HOME\_vimrc'
  " keep the same .vim name instead of vimfiles
  set runtimepath=$HOME/.vim,$VIM/vimfiles,$VIMRUNTIME,$VIM/vimfiles/after,$HOME/.vim/after
else
  let vimrc='$HOME/.vimrc'
endif
" }

" Configure Vundle {
" This expects Vundle is already cloned into bundles directory
filetype off
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
" Vundle bundles
if filereadable(expand("~/.vim/vimrc.bundles"))
  source ~/.vim/vimrc.bundles
  source ~/.vim/vimrc.bundles.local
endif
call vundle#end()
" }

" Settings {
set nocompatible " we want VIM not VI!

"========== File/buffer handling
set autoread " read the file again when it's changed outside vim and not inside vim
set autowrite " write file when :next, :rewind, :last, :first, :previous, :stop, :suspend, :tag, :!, :make commands are used
set nobackup " backups are for wimps  ;-)
set backupcopy=yes " see :help crontab
set encoding=utf-8
set hidden " keep the changed buffer without saving it
set writebackup " make a backup before overwriting a file. then remove it after the file was successfully written

"========== Tabs and spaces
set autoindent " copy indent from current line when starting a new line
set expandtab " use only spaces instead of tabs
set shiftwidth=2 " number of spaces to use for each step of (auto)indent
set smarttab " smart handling of tab at the front of the line vs in the line
set softtabstop=2 " number of spaces to use for each <Tab> or <BS> in editing
set tabstop=8 " real tabs are 8 spaces

"========== Folding
set foldenable " folding is good
set foldmethod=indent " make folding indent sensitive
set foldlevel=10 " don't start folding too early

"========== Display
set background=dark " use the dark bg color set
set cursorline " makes cursor easier to find
set nocursorcolumn " don't make cursor TOO easy to find - too distracting
set display+=lastline " display last line as much as possible
set laststatus=2 " always show status line
set lazyredraw " don't update screen while executing macros, registers and other commands that have not been typed
set list " show trailing whitespace
set listchars=tab:▸\ ,trail:▫ " set nicer chars for tabs and trailing spaces
set modeline " do use modelines
set number " do show line numbers
set report=0 " report all changed lines
set ruler " show cursor position always
set scrolloff=1 " show 1 row context above/below cursorline
set sidescrolloff=5 " show 5 columns as context
set shortmess+=atI " abbreviate all messages
set showcmd " show current uncompleted command
set showmatch " show matching bracket briefly
set showmode " show the current mode
"my status line
set statusline=%F%m%r%h%w\ [FORMAT=%{&ff}]\ [TYPE=%Y]\ [%p%%][POS=%l,%v][LINES=%L]
"show syntastic error in status line
set statusline+=%#warningmsg#%{SyntasticStatuslineFlag()}%*
set tabpagemax=50 " limit tabs opened
set title " have vim try to update the title of the window
set ttimeout ttimeoutlen=100 " timeout keycode after 100ms, do not timeout mappings
set ttyfast " we are on a fast connection
set wildchar=<Tab> " use tab to start wildcard expansion in the command-line
set wildignore=log/**,node_modules/**,target/**,tmp/**,*.rbc " ignore some files/directories for completion
set wildmenu " show a navigable menu for tab completion
set wildmode=longest,list,full " longest match, and list if can't match only one

set noerrorbells " disable error bell beep
if WINDOWS()
  set novisualbell
else
  set visualbell " use visual bell, but we will disable it later
  set t_vb= " disable visualbell terminal chars
endif

"========== Editting
set backspace=indent,eol,start " this is much smarter. back over autoindent,<EOL> and insert position
set clipboard=unnamed " yank and paste with the system clipboard
set esckeys " allow cursor movement in insert mode
set formatoptions+=2j " better indenting. join comment lines better
set nrformats-=octal " octal would cause numbers with leading zero to be treated as octal. Not good with ^A and ^X
set virtualedit=all " allow cursor movement anywhere
set whichwrap+=<,>,[,] " allow left, right keys to wrap in normal/visual mode

"========== History and Searching
set history=1000 " keep 1000 commands and 1000 search patterns in the history.
set hlsearch " highlight searches
set incsearch " display the match for a search pattern when halfway typing it
set ignorecase " do ignore case in search patterns. This works well with smartcase set on
set smartcase " ignore case when the pattern contains lowercase letters only

" Enable basic mouse behavior such as resizing buffers.
set mouse=a
if exists('$TMUX')  " Support resizing in tmux
  set ttymouse=xterm2
endif
" }

" Plugin settings {
" Lightline status line {
let g:lightline = {
  \ 'colorscheme': 'solarized',
  \ 'active': {
  \   'left': [ [ 'mode', 'paste' ],
  \             [ 'fugitive', 'readonly', 'filename', 'modified' ] ]
  \ },
  \ 'component': {
  \   'fugitive': '%{exists("*fugitive#head")?fugitive#head():""}'
  \ },
  \ 'component_visible_condition': {
  \   'fugitive': '(exists("*fugitive#head") && ""!=fugitive#head())'
  \ },
\ }
" }

let g:gitgutter_enabled = 1 " do enable git gutter

let g:ctrlp_match_window = 'order:ttb,max:15' " change CtrlP search result order and size
" Use The Silver Searcher https://github.com/ggreer/the_silver_searcher
if executable('ag')
  " Use Ag over Grep
  set grepprg=ag\ --nogroup\ --nocolor
  " Use ag in CtrlP for listing files. Lightning fast and respects .gitignore
  let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'
endif

" enable completion from tags
let g:ycm_collect_identifiers_from_tags_files = 1
let g:ycm_server_keep_logfiles = 0
let g:ycm_server_log_level = 'info'

" enable omni completion.
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete
autocmd FileType haskell setlocal omnifunc=necoghc#omnifunc

let g:UltiSnipsExpandTrigger="<c-j>"
let g:UltiSnipsJumpForwardTrigger="<c-j>"
let g:UltiSnipsJumpBackwardTrigger="<c-k>"
let g:UltiSnipsListSnippets="<c-l>"
let g:UltiSnipsEditSplit="vertical"

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0

" Extend the expansion text objects
call expand_region#custom_text_objects({
      \ 'a]'  :1,
      \ 'ab'  :1,
      \ 'aB'  :1,
      \ 'ii'  :0,
      \ 'ai'  :0,
\ })

" Load matchit.vim, but only if the user hasn't installed a newer version.
if !exists('g:loaded_matchit') && findfile('plugin/matchit.vim', &rtp) ==# ''
  runtime! macros/matchit.vim
endif
" }

" Key mappings {
let mapleader = ','
let g:mapleader = ','
let maplocalleader = ','
let g:maplocalleader = ','

" jj quickly in insertmode gives escape key
inoremap jj <esc>
" n / N are updated to always center (vertically) the matches
nnoremap n nzzzv
nnoremap N Nzzzv
" p in visual mode yank into blackhole register before pasting
vnoremap p "_dP
" Q quits - normally Q opens ex-mode, never uses it
nnoremap Q :q<cr>
" U redos - normally U undo a whole line, never uses it
nnoremap U :redo<cr>
" rewrite the file with sudo
cnoremap w!! w !sudo tee > /dev/null %
" >, <: reselect visual block after indent
xnoremap > >gv
xnoremap < <gv
" CTRL-A normal mode: increment number
" CTRL-X normal mode: decrement number
" insert mode ^u will clear line, but undo buffer now saves the cleared text.
inoremap <c-u> <c-g>u<c-u>
" insert mode ^w will clear word, but undo buffer now saves the cleared text.
inoremap <c-w> <c-g>u<c-w>
" <cr>: highlight visual selections
xnoremap <cr> y:let @/ = @"<cr>:set hlsearch<cr>

" leader key bindings in alpha order
nnoremap <leader><space> :call whitespace#strip_trailing()<cr>
" toggle paste mode
nnoremap <leader>1 :set paste!<cr>
nnoremap <leader>a :Ag<space>
nnoremap <leader>b :CtrlPBuffer<cr>
" cd: Switch to the directory of the open buffer
nnoremap <leader>cd :cd %:p:h<cr>:pwd<cr>
" cel = clear empty lines - deletes all empty or whitespace only lines
vnoremap <leader>cel :g/^[<c-i> ]*$/d<cr>
nnoremap <leader>d :NERDTreeToggle<cr>
nnoremap <leader>f :NERDTreeFind<cr>
nnoremap <leader>g :GitGutterToggle<cr>
" clear hlsearch highlights
nnoremap <leader>hl :let @/ = ""<cr>
nnoremap <leader>l :Tabularize<space>/
vnoremap <leader>l :Tabularize<space>/
" quit all - useful when viewing vimdiff
nnoremap <leader>q :qall<cr>
" ri = re-indent whole file and put you back to where you were
" a bit magic here: save current location, save top of window loc,
" reformat gg=G, move back to original top of windows, and then last line
nnoremap <leader>ri mqHmwgg=G`wzt`q
" rcm = remove ^M from DOS file
nnoremap <leader>rcm :%s/<c-v><c-m>//g<cr>
nnoremap <leader>t :CtrlP<cr>
nnoremap <leader>T :CtrlPClearCache<cr>:CtrlP<cr>
nnoremap <leader>u :GundoToggle<cr>
" vimrc editing (edit this file)
nnoremap <leader>v :exe ":edit " . vimrc<cr>
" reload vimrc by reading this file
nnoremap <leader>V :exe ":source " . vimrc<cr>
nnoremap <leader>] :TagbarToggle<cr>

" window movements
nnoremap <c-h> <c-w>h
nnoremap <c-j> <c-w>j
nnoremap <c-k> <c-w>k
nnoremap <c-l> <c-w>l
" switch to the other window ala ^w^w, but maximize the target window too
nnoremap <c-w><c-e> <c-w><c-w><c-w>_<cr>
" <leader>m: Maximize current split
nnoremap <leader>m <c-w>_<c-w><bar>
" <leader>,: Switch to previous split
nnoremap <leader>, <c-w>p

" THIS ISN'T WORKING IN MAC
"
" alt/meta keys
" Fix alt/meta key keycodes. Using keycodes instead of
" escape sequence for mapping will use ttimeout instead of timeout,
" which means pressing escape will not cause a delay.
" let c='a'
" while c <= 'z'
"   exec "set <a-".c.">=\e".c
"   exec "set <a-".toupper(c).">=\e".toupper(c)
"   let c = nr2char(1+char2nr(c))
" endw

" normal mode: move current line down/up
" nnoremap <a-j> mz:m+<cr>`z==
" nnoremap <a-k> mz:m-2<cr>`z==

" insert model: move current line down/up
" imap <a-j> <esc><m-j>a
" imap <a-k> <esc><m-k>a

" visual mode: move blocks down/up
" vnoremap <a-j> :m'>+<cr>`<my`>mzgv`yo`z
" vnoremap <a-k> :m'<-2<cr>`>my`<mzgv`yo`z

" }

" GUI configuration {
if has("gui_running")
  set columns=132 " default to 132 columns
  set lines=50 " default to 50 lines

  set guicursor=a:blinkon0 " diable blinky cursor
  set mousehide " hide the mouse when typing

  " at some point the fonts will be needed
  if OSX()
    set guifont=Bitstream\ Vera\ Sans\ Mono:h11,Menlo\ Regular:h11,Andale\ Mono:h11
  elseif WINDOWS()
    set guifont=Bitstream_Vera_Sans_Mono:h10,DejaVu_Sans_Mono:h10,Consolas:h10
  else
    set guifont=Bitstream\ Vera\ Sans\ Mono\ 10,DejaVu\ Sans\ Mono\ 10,Consolas\ 10
  endif
endif
" }

filetype plugin indent on " enable file type detection.
syntax on " turn on syntax highlighting
colorscheme solarized

" set extensions for markdown files
autocmd BufNewFile,BufRead *.markdown,*.mkd,*.md set filetype=markdown
" markdown files should have spell checking
autocmd BufNewFile,BufRead *.markdown,*.mkd,*.md set spell
" restore last edit position if we can
autocmd BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$") | exe "normal! g`\"" | endif
" automatically rebalance windows on vim resize
autocmd VimResized * :wincmd =

if filereadable(expand("~/.vim/vimrc.local"))
  source ~/.vim/vimrc.local
endif
